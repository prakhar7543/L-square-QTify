"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToastViewport = useToastViewport;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _ToastProviderContext = require("../provider/ToastProviderContext");
var _owner = require("../../utils/owner");
var _focusVisible = require("../utils/focusVisible");
var _useLatestRef = require("../../utils/useLatestRef");
var _mergeProps = require("../../merge-props");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useToastViewport() {
  const {
    toasts,
    pauseTimers,
    resumeTimers,
    setHovering,
    setFocused,
    viewportRef,
    focused,
    windowFocusedRef,
    prevFocusElement,
    setPrevFocusElement
  } = (0, _ToastProviderContext.useToastContext)();
  const handlingFocusGuardRef = React.useRef(false);
  const focusedRef = (0, _useLatestRef.useLatestRef)(focused);
  const numToasts = toasts.length;

  // Listen globally for F6 so we can force-focus the viewport.
  React.useEffect(() => {
    if (!viewportRef.current) {
      return undefined;
    }
    function handleGlobalKeyDown(event) {
      if (numToasts === 0) {
        return;
      }
      if (event.key === 'F6' && event.target !== viewportRef.current) {
        event.preventDefault();
        setPrevFocusElement((0, _utils.activeElement)((0, _owner.ownerDocument)(viewportRef.current)));
        viewportRef.current?.focus();
        pauseTimers();
        setFocused(true);
      }
    }
    const win = (0, _owner.ownerWindow)(viewportRef.current);
    win.addEventListener('keydown', handleGlobalKeyDown);
    return () => {
      win.removeEventListener('keydown', handleGlobalKeyDown);
    };
  }, [pauseTimers, setFocused, setPrevFocusElement, numToasts, viewportRef]);
  React.useEffect(() => {
    if (!viewportRef.current || !numToasts) {
      return undefined;
    }
    const win = (0, _owner.ownerWindow)(viewportRef.current);
    function handleWindowBlur(event) {
      if (event.target !== win) {
        return;
      }
      windowFocusedRef.current = false;
      pauseTimers();
    }
    function handleWindowFocus(event) {
      if (event.relatedTarget || event.target === win) {
        return;
      }
      const target = (0, _utils.getTarget)(event);
      const activeEl = (0, _utils.activeElement)((0, _owner.ownerDocument)(viewportRef.current));
      if (!(0, _utils.contains)(viewportRef.current, target) || !(0, _focusVisible.isFocusVisible)(activeEl)) {
        resumeTimers();
      }

      // Wait for the `handleFocus` event to fire.
      setTimeout(() => {
        windowFocusedRef.current = true;
      });
    }
    win.addEventListener('blur', handleWindowBlur, true);
    win.addEventListener('focus', handleWindowFocus, true);
    return () => {
      win.removeEventListener('blur', handleWindowBlur, true);
      win.removeEventListener('focus', handleWindowFocus, true);
    };
  }, [pauseTimers, resumeTimers, viewportRef, windowFocusedRef, setFocused, focusedRef,
  // `viewportRef.current` isn't available on the first render,
  // since the portal node hasn't yet been created.
  // By adding this dependency, we ensure the window listeners
  // are added when toasts have been created, once the ref is available.
  numToasts]);
  function handleFocusGuard(event) {
    if (!viewportRef.current) {
      return;
    }
    handlingFocusGuardRef.current = true;

    // If we're coming off the container, move to the first toast
    if (event.relatedTarget === viewportRef.current) {
      toasts[0]?.ref?.current?.focus();
    } else {
      prevFocusElement?.focus({
        preventScroll: true
      });
    }
  }
  function handleKeyDown(event) {
    if (event.key === 'Tab' && event.shiftKey && event.target === viewportRef.current) {
      event.preventDefault();
      prevFocusElement?.focus({
        preventScroll: true
      });
      resumeTimers();
    }
  }
  function handleMouseEnter() {
    pauseTimers();
    setHovering(true);
  }
  function handleMouseLeave() {
    const activeEl = (0, _utils.activeElement)((0, _owner.ownerDocument)(viewportRef.current));
    if ((0, _utils.contains)(viewportRef.current, activeEl) && (0, _focusVisible.isFocusVisible)(activeEl)) {
      return;
    }
    resumeTimers();
    setHovering(false);
  }
  function handleFocus() {
    if (handlingFocusGuardRef.current) {
      handlingFocusGuardRef.current = false;
      return;
    }
    if (focused) {
      return;
    }

    // If the window was previously blurred, the focus must be visible to
    // pause the timers, since for pointers it's unexpected that focus is
    // considered inside the viewport at this point.
    const activeEl = (0, _utils.activeElement)((0, _owner.ownerDocument)(viewportRef.current));
    if (!windowFocusedRef.current && !(0, _focusVisible.isFocusVisible)(activeEl)) {
      return;
    }
    setFocused(true);
    pauseTimers();
  }
  function handleBlur(event) {
    if (!focused || (0, _utils.contains)(viewportRef.current, event.relatedTarget)) {
      return;
    }
    setFocused(false);
    resumeTimers();
  }
  function getViewportProps(externalProps = {}) {
    return (0, _mergeProps.mergeProps)({
      role: 'region',
      tabIndex: -1,
      'aria-label': `${numToasts} notification${numToasts !== 1 ? 's' : ''} (F6)`,
      onMouseEnter: handleMouseEnter,
      onMouseMove: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onClick: handleFocus
    }, externalProps);
  }
  const contextValue = React.useMemo(() => ({
    viewportRef
  }), [viewportRef]);
  return {
    viewportRef,
    numToasts,
    prevFocusElement,
    toasts,
    handleFocusGuard,
    getViewportProps,
    contextValue
  };
}