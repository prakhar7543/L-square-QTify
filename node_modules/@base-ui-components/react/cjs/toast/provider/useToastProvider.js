"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToastProvider = useToastProvider;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _generateId = require("../../utils/generateId");
var _resolvePromiseOptions = require("../utils/resolvePromiseOptions");
var _useEventCallback = require("../../utils/useEventCallback");
var _useLatestRef = require("../../utils/useLatestRef");
var _owner = require("../../utils/owner");
var _focusVisible = require("../utils/focusVisible");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useToastProvider(props) {
  const {
    timeout = 5000,
    limit = 3,
    toastManager
  } = props;
  const [toasts, setToasts] = React.useState([]);
  const [hovering, setHovering] = React.useState(false);
  const [focused, setFocused] = React.useState(false);
  const [prevFocusElement, setPrevFocusElement] = React.useState(null);
  if (toasts.length === 0) {
    if (hovering) {
      setHovering(false);
    }
    if (focused) {
      setFocused(false);
    }
  }

  // It's not possible to stack a smaller height toast onto a larger height toast, but
  // the reverse is possible. For simplicity, we'll enforce the expanded state if the
  // toasts aren't all the same height.
  const hasDifferingHeights = React.useMemo(() => {
    const heights = toasts.map(t => t.height).filter(h => h !== 0);
    return heights.length > 0 && new Set(heights).size > 1;
  }, [toasts]);
  const timersRef = React.useRef(new Map());
  const viewportRef = React.useRef(null);
  const windowFocusedRef = React.useRef(true);
  const isPausedRef = React.useRef(false);
  const hoveringRef = (0, _useLatestRef.useLatestRef)(hovering);
  const focusedRef = (0, _useLatestRef.useLatestRef)(focused);
  const handleFocusManagement = (0, _useEventCallback.useEventCallback)(toastId => {
    const activeEl = (0, _utils.activeElement)((0, _owner.ownerDocument)(viewportRef.current));
    if (!viewportRef.current || !(0, _utils.contains)(viewportRef.current, activeEl) || !(0, _focusVisible.isFocusVisible)(activeEl)) {
      return;
    }
    const currentIndex = toasts.findIndex(toast => toast.id === toastId);
    let nextToast = null;

    // Try to find the next toast that isn't animating out
    let index = currentIndex + 1;
    while (index < toasts.length) {
      if (toasts[index].transitionStatus !== 'ending') {
        nextToast = toasts[index];
        break;
      }
      index += 1;
    }

    // Go backwards if no next toast is found
    if (!nextToast) {
      index = currentIndex - 1;
      while (index >= 0) {
        if (toasts[index].transitionStatus !== 'ending') {
          nextToast = toasts[index];
          break;
        }
        index -= 1;
      }
    }
    if (nextToast) {
      nextToast.ref?.current?.focus();
    } else {
      prevFocusElement?.focus({
        preventScroll: true
      });
    }
  });
  const pauseTimers = (0, _useEventCallback.useEventCallback)(() => {
    if (isPausedRef.current) {
      return;
    }
    isPausedRef.current = true;
    timersRef.current.forEach(timer => {
      if (timer.timeoutId) {
        clearTimeout(timer.timeoutId);
        const elapsed = Date.now() - timer.start;
        const remaining = timer.delay - elapsed;
        timer.remaining = remaining > 0 ? remaining : 0;
      }
    });
  });
  const resumeTimers = (0, _useEventCallback.useEventCallback)(() => {
    if (!isPausedRef.current) {
      return;
    }
    isPausedRef.current = false;
    timersRef.current.forEach((timer, id) => {
      timer.remaining = timer.remaining > 0 ? timer.remaining : timer.delay;
      timer.timeoutId = setTimeout(() => {
        timersRef.current.delete(id);
        timer.callback();
      }, timer.remaining);
      timer.start = Date.now();
    });
  });
  const close = (0, _useEventCallback.useEventCallback)(toastId => {
    setToasts(prev => prev.map(toast => toast.id === toastId ? {
      ...toast,
      transitionStatus: 'ending',
      height: 0
    } : toast));
    const timer = timersRef.current.get(toastId);
    if (timer && timer.timeoutId) {
      clearTimeout(timer.timeoutId);
      timersRef.current.delete(toastId);
    }
    const toast = toasts.find(t => t.id === toastId);
    toast?.onClose?.();
    handleFocusManagement(toastId);
    if (toasts.length === 1) {
      hoveringRef.current = false;
      focusedRef.current = false;
    }
  });
  const remove = (0, _useEventCallback.useEventCallback)(toastId => {
    setToasts(prev => prev.filter(toast => toast.id !== toastId));
    const toast = toasts.find(t => t.id === toastId);
    toast?.onRemove?.();
  });
  const scheduleTimer = (0, _useEventCallback.useEventCallback)((id, delay, callback) => {
    const start = Date.now();
    const shouldStartActive = windowFocusedRef.current && !hoveringRef.current && !focusedRef.current;
    const timeoutId = shouldStartActive ? setTimeout(() => {
      timersRef.current.delete(id);
      callback();
    }, delay) : undefined;
    timersRef.current.set(id, {
      timeoutId,
      start: shouldStartActive ? start : 0,
      delay,
      remaining: delay,
      callback
    });
  });
  const add = (0, _useEventCallback.useEventCallback)(toast => {
    const id = toast.id || (0, _generateId.generateId)('toast');
    const toastToAdd = {
      ...toast,
      id,
      transitionStatus: 'starting'
    };
    setToasts(prev => {
      const updatedToasts = [toastToAdd, ...prev];
      const activeToasts = updatedToasts.filter(t => t.transitionStatus !== 'ending');

      // Mark oldest toasts for removal when over limit
      if (activeToasts.length > limit) {
        const excessCount = activeToasts.length - limit;
        const oldestActiveToasts = activeToasts.slice(-excessCount);
        oldestActiveToasts.forEach(t => {
          const timer = timersRef.current.get(t.id);
          if (timer && timer.timeoutId) {
            clearTimeout(timer.timeoutId);
          }
          timersRef.current.delete(t.id);
        });
        return updatedToasts.map(t => oldestActiveToasts.some(old => old.id === t.id) ? {
          ...t,
          transitionStatus: 'ending',
          limited: true
        } : t);
      }
      return updatedToasts;
    });
    const duration = toastToAdd.timeout ?? timeout;
    if (toastToAdd.type !== 'loading' && duration > 0) {
      scheduleTimer(id, duration, () => close(id));
    }
    if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
      pauseTimers();
    }
    return id;
  });
  const update = (0, _useEventCallback.useEventCallback)((id, updates) => {
    setToasts(prev => prev.map(toast => toast.id === id ? {
      ...toast,
      ...updates
    } : toast));
  });
  const promise = (0, _useEventCallback.useEventCallback)((promiseValue, options) => {
    // Create a loading toast (which does not auto-dismiss).
    const loadingOptions = (0, _resolvePromiseOptions.resolvePromiseOptions)(options.loading);
    const id = add({
      ...loadingOptions,
      type: 'loading'
    });
    const handledPromise = promiseValue.then(result => {
      update(id, {
        ...(0, _resolvePromiseOptions.resolvePromiseOptions)(options.success, result),
        type: 'success'
      });
      scheduleTimer(id, timeout, () => close(id));
      if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
        pauseTimers();
      }
      return result;
    }).catch(error => {
      update(id, {
        ...(0, _resolvePromiseOptions.resolvePromiseOptions)(options.error, error),
        type: 'error'
      });
      scheduleTimer(id, timeout, () => close(id));
      if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
        pauseTimers();
      }
      return Promise.reject(error);
    });

    // Private API used exclusively by `Manager` to handoff the promise
    // back to the manager after it's handled here.
    if ({}.hasOwnProperty.call(options, 'setPromise')) {
      options.setPromise(handledPromise);
    }
    return handledPromise;
  });
  React.useEffect(function subscribeToToastManager() {
    if (!toastManager) {
      return undefined;
    }
    const unsubscribe = toastManager[' subscribe'](({
      action,
      options
    }) => {
      const id = options.id;
      if (action === 'promise' && options.promise) {
        promise(options.promise, options);
      } else if (action === 'update' && id) {
        update(id, options);
      } else if (action === 'close' && id) {
        close(id);
      } else {
        add(options);
      }
    });
    return unsubscribe;
  }, [add, update, scheduleTimer, timeout, toastManager, promise, close]);
  return React.useMemo(() => ({
    toasts,
    setToasts,
    hovering,
    setHovering,
    focused,
    setFocused,
    add,
    close,
    remove,
    update,
    promise,
    pauseTimers,
    resumeTimers,
    prevFocusElement,
    setPrevFocusElement,
    viewportRef,
    scheduleTimer,
    windowFocusedRef,
    hasDifferingHeights
  }), [add, close, focused, hovering, pauseTimers, prevFocusElement, promise, remove, resumeTimers, scheduleTimer, toasts, update, hasDifferingHeights]);
}