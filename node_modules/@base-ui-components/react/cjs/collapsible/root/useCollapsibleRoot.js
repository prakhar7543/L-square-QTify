"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCollapsibleRoot = useCollapsibleRoot;
var React = _interopRequireWildcard(require("react"));
var _useAnimationsFinished = require("../../utils/useAnimationsFinished");
var _useBaseUiId = require("../../utils/useBaseUiId");
var _useControlled = require("../../utils/useControlled");
var _useEnhancedEffect = require("../../utils/useEnhancedEffect");
var _useEventCallback = require("../../utils/useEventCallback");
var _useTransitionStatus = require("../../utils/useTransitionStatus");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useCollapsibleRoot(parameters) {
  const {
    open: openParam,
    defaultOpen,
    onOpenChange,
    disabled
  } = parameters;
  const isControlledRef = React.useRef(openParam !== undefined);
  const [open, setOpen] = (0, _useControlled.useControlled)({
    controlled: openParam,
    default: defaultOpen,
    name: 'Collapsible',
    state: 'open'
  });
  const {
    mounted,
    setMounted,
    transitionStatus
  } = (0, _useTransitionStatus.useTransitionStatus)(open);
  const [visible, setVisible] = React.useState(open);
  const [{
    height,
    width
  }, setDimensions] = React.useState({
    height: undefined,
    width: undefined
  });
  const [panelId, setPanelId] = React.useState((0, _useBaseUiId.useBaseUiId)());
  const [hiddenUntilFound, setHiddenUntilFound] = React.useState(false);
  const [keepMounted, setKeepMounted] = React.useState(false);
  const abortControllerRef = React.useRef(null);
  const animationTypeRef = React.useRef(null);
  const transitionDimensionRef = React.useRef(null);
  const panelRef = React.useRef(null);
  const runOnceAnimationsFinish = (0, _useAnimationsFinished.useAnimationsFinished)(panelRef, false);
  const handleTrigger = (0, _useEventCallback.useEventCallback)(() => {
    const nextOpen = !open;
    const panel = panelRef.current;
    if (animationTypeRef.current === 'css-animation' && panel != null) {
      panel.style.removeProperty('animation-name');
    }
    if (!hiddenUntilFound && !keepMounted) {
      if (animationTypeRef.current != null && animationTypeRef.current !== 'css-animation') {
        if (!mounted && nextOpen) {
          setMounted(true);
        }
      }
      if (animationTypeRef.current === 'css-animation') {
        if (!visible && nextOpen) {
          setVisible(true);
        }
        if (!mounted && nextOpen) {
          setMounted(true);
        }
      }
    }
    setOpen(nextOpen);
    onOpenChange(nextOpen);
    if (animationTypeRef.current === 'none') {
      if (mounted && !nextOpen) {
        setMounted(false);
      }
      return;
    }
    if (!panel || animationTypeRef.current !== 'css-transition' ||
    /**
     * Defer to an effect when controlled, as the open state can be changed
     * externally without interacting with the trigger.
     */
    isControlledRef.current || (
    /**
     * Defer to an effect When `keepMounted={false}` and when opening, the
     * element may not exist in the DOM at this point.
     */
    !keepMounted && nextOpen)) {
      return;
    }
    if (abortControllerRef.current != null) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    panel.style.setProperty('display', 'block', 'important');
    if (nextOpen) {
      /* opening */

      panel.style.removeProperty('content-visibility');
      panel.style.setProperty(transitionDimensionRef.current ?? 'height', '0px');
      requestAnimationFrame(() => {
        panel.style.removeProperty(transitionDimensionRef.current ?? 'height');
        setDimensions({
          height: panel.scrollHeight,
          width: panel.scrollWidth
        });
        panel.style.removeProperty('display');
      });
    } else {
      if (hiddenUntilFound) {
        panel.style.setProperty('content-visibility', 'visible');
      }
      /* closing */
      requestAnimationFrame(() => {
        setDimensions({
          height: 0,
          width: 0
        });
      });
      abortControllerRef.current = new AbortController();
      runOnceAnimationsFinish(() => {
        setMounted(false);
        panel.style.removeProperty('display');
        panel.style.removeProperty('content-visibility');
        abortControllerRef.current = null;
      }, abortControllerRef.current.signal);
    }
  });
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    /**
     * Unmount immediately when closing in controlled mode and keepMounted={false}
     * and no CSS animations or transitions are applied
     */
    if (isControlledRef.current && animationTypeRef.current === 'none' && !keepMounted && !open) {
      setMounted(false);
    }
  }, [keepMounted, open, openParam, setMounted]);
  return React.useMemo(() => ({
    abortControllerRef,
    animationTypeRef,
    disabled,
    handleTrigger,
    height,
    mounted,
    open,
    panelId,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setHiddenUntilFound,
    setKeepMounted,
    setMounted,
    setOpen,
    setPanelId,
    setVisible,
    transitionDimensionRef,
    transitionStatus,
    visible,
    width
  }), [abortControllerRef, animationTypeRef, disabled, handleTrigger, height, mounted, open, panelId, panelRef, runOnceAnimationsFinish, setDimensions, setHiddenUntilFound, setKeepMounted, setMounted, setOpen, setPanelId, setVisible, transitionDimensionRef, transitionStatus, visible, width]);
}