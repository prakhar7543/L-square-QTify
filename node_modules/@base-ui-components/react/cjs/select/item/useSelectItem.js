"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSelectItem = useSelectItem;
var React = _interopRequireWildcard(require("react"));
var _useButton = require("../../use-button");
var _mergeProps = require("../../merge-props");
var _useEventCallback = require("../../utils/useEventCallback");
var _useForkRef = require("../../utils/useForkRef");
var _utils = require("../../utils");
var _highlighted = require("../../utils/highlighted");
var _isMouseWithinBounds = require("../../utils/isMouseWithinBounds");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useSelectItem(params) {
  const {
    open,
    disabled = false,
    highlighted,
    selected,
    ref: externalRef,
    setOpen,
    typingRef,
    handleSelect,
    selectionRef,
    indexRef,
    setActiveIndex,
    selectedIndexRef,
    popupRef,
    keyboardActiveRef,
    events
  } = params;
  const ref = React.useRef(null);
  const lastKeyRef = React.useRef(null);
  const pointerTypeRef = React.useRef('mouse');
  const didPointerDownRef = React.useRef(false);
  const prevPopupHeightRef = React.useRef(0);
  const allowFocusSyncRef = React.useRef(true);
  const cursorMovementTimerRef = React.useRef(-1);
  const mergedRef = (0, _useForkRef.useForkRef)(externalRef, ref);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    focusableWhenDisabled: true,
    buttonRef: mergedRef
  });
  const commitSelection = (0, _useEventCallback.useEventCallback)(event => {
    handleSelect(event);
    setOpen(false, event, undefined);
  });
  const handlePopupLeave = (0, _useEventCallback.useEventCallback)(() => {
    if (cursorMovementTimerRef.current !== -1) {
      clearTimeout(cursorMovementTimerRef.current);
      cursorMovementTimerRef.current = -1;
      (0, _highlighted.removeHighlight)(ref);
    }
  });
  React.useEffect(() => {
    return handlePopupLeave;
  }, [handlePopupLeave]);
  (0, _utils.useEnhancedEffect)(() => {
    if (!open) {
      return;
    }
    if (highlighted) {
      (0, _highlighted.addHighlight)(ref);
    } else {
      (0, _highlighted.removeHighlight)(ref);
    }
  }, [open, highlighted]);
  React.useEffect(() => {
    function handleItemHover(item) {
      if (ref.current && item !== ref.current) {
        (0, _highlighted.removeHighlight)(ref);
      }
    }
    events.on('itemhover', handleItemHover);
    return () => {
      events.off('itemhover', handleItemHover);
    };
  }, [events, setActiveIndex, indexRef]);
  const getItemProps = React.useCallback(externalProps => {
    return getButtonProps((0, _mergeProps.mergeProps)({
      'aria-disabled': disabled || undefined,
      tabIndex: highlighted ? 0 : -1,
      onFocus() {
        if (allowFocusSyncRef.current && keyboardActiveRef.current && cursorMovementTimerRef.current === -1) {
          setActiveIndex(indexRef.current);
        }
      },
      onMouseEnter() {
        if (!keyboardActiveRef.current && selectedIndexRef.current === null) {
          (0, _highlighted.addHighlight)(ref);
          events.emit('itemhover', ref.current);
        }
      },
      onMouseMove() {
        if (keyboardActiveRef.current) {
          setActiveIndex(indexRef.current);
        } else {
          (0, _highlighted.addHighlight)(ref);
          events.emit('itemhover', ref.current);
        }
        if (popupRef.current) {
          prevPopupHeightRef.current = popupRef.current.offsetHeight;
        }
        if (cursorMovementTimerRef.current !== -1) {
          events.off('popupleave', handlePopupLeave);
          clearTimeout(cursorMovementTimerRef.current);
        }
        events.on('popupleave', handlePopupLeave);
        // When this fires, the cursor has stopped moving.
        cursorMovementTimerRef.current = window.setTimeout(() => {
          setActiveIndex(indexRef.current);
          cursorMovementTimerRef.current = -1;
        }, 50);
      },
      onMouseLeave(event) {
        const popup = popupRef.current;
        if (!popup || !open || keyboardActiveRef.current) {
          return;
        }
        if ((0, _isMouseWithinBounds.isMouseWithinBounds)(event)) {
          return;
        }
        (0, _highlighted.removeHighlight)(ref);
        events.off('popupleave', handlePopupLeave);
        const wasCursorStationary = cursorMovementTimerRef.current === -1;
        if (!wasCursorStationary) {
          clearTimeout(cursorMovementTimerRef.current);
          cursorMovementTimerRef.current = -1;
        }

        // With `alignItemToTrigger`, avoid re-rendering the root due to `onMouseLeave`
        // firing and causing a performance issue when expanding the popup.
        if (popup.offsetHeight === prevPopupHeightRef.current) {
          // Prevent `onFocus` from causing the highlight to be stuck when quickly moving
          // the mouse out of the popup.
          allowFocusSyncRef.current = false;
          if (keyboardActiveRef.current || wasCursorStationary) {
            setActiveIndex(null);
          }
          requestAnimationFrame(() => {
            if (cursorMovementTimerRef.current !== -1) {
              clearTimeout(cursorMovementTimerRef.current);
            }
            allowFocusSyncRef.current = true;
          });
        }
      },
      onTouchStart() {
        selectionRef.current = {
          allowSelectedMouseUp: false,
          allowUnselectedMouseUp: false,
          allowSelect: true
        };
      },
      onKeyDown(event) {
        selectionRef.current.allowSelect = true;
        lastKeyRef.current = event.key;
        setActiveIndex(indexRef.current);
      },
      onClick(event) {
        didPointerDownRef.current = false;

        // Prevent double commit on {Enter}
        if (event.type === 'keydown' && lastKeyRef.current === null) {
          return;
        }
        if (disabled || lastKeyRef.current === ' ' && typingRef.current || pointerTypeRef.current !== 'touch' && !(0, _highlighted.hasHighlight)(ref)) {
          return;
        }
        if (selectionRef.current.allowSelect) {
          lastKeyRef.current = null;
          commitSelection(event.nativeEvent);
        }
      },
      onPointerEnter(event) {
        pointerTypeRef.current = event.pointerType;
      },
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
        didPointerDownRef.current = true;
      },
      onMouseUp(event) {
        if (disabled) {
          return;
        }
        if (didPointerDownRef.current) {
          didPointerDownRef.current = false;
          return;
        }
        const disallowSelectedMouseUp = !selectionRef.current.allowSelectedMouseUp && selected;
        const disallowUnselectedMouseUp = !selectionRef.current.allowUnselectedMouseUp && !selected;
        if (disallowSelectedMouseUp || disallowUnselectedMouseUp || pointerTypeRef.current !== 'touch' && !(0, _highlighted.hasHighlight)(ref)) {
          return;
        }
        if (selectionRef.current.allowSelect || !selected) {
          commitSelection(event.nativeEvent);
        }
        selectionRef.current.allowSelect = true;
      }
    }, externalProps, getButtonProps));
  }, [commitSelection, disabled, events, getButtonProps, handlePopupLeave, highlighted, indexRef, keyboardActiveRef, open, popupRef, selected, selectedIndexRef, selectionRef, setActiveIndex, typingRef]);
  return React.useMemo(() => ({
    getItemProps,
    rootRef: buttonRef
  }), [getItemProps, buttonRef]);
}