"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIOSKeyboardSlideFix = useIOSKeyboardSlideFix;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _useEnhancedEffect = require("./useEnhancedEffect");
var _detectBrowser = require("./detectBrowser");
var _owner = require("./owner");
var _useEventCallback = require("./useEventCallback");
var _useScrollLock = require("./useScrollLock");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Temporarily allows disabling the scroll lock when a typeable element (e.g. input or textarea)
 * is focused. This allows the document to slide up when the keyboard is shown on iOS.
 * Scroll needs to be manually restored since the sliding causes the page to scroll in the
 * background.
 * https://github.com/mui/base-ui/issues/1455
 */
function useIOSKeyboardSlideFix(params) {
  const {
    enabled,
    setLock: setLockParam,
    popupRef
  } = params;
  const setLock = (0, _useEventCallback.useEventCallback)(setLockParam);
  const hasBeenEnabledRef = React.useRef(enabled);
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    if (!(0, _detectBrowser.isIOS)()) {
      return undefined;
    }
    if (enabled) {
      hasBeenEnabledRef.current = true;
    }
    if (!hasBeenEnabledRef.current) {
      return undefined;
    }
    const doc = (0, _owner.ownerDocument)(popupRef.current);
    const html = doc.documentElement;
    if (enabled) {
      const scrollX = html.scrollLeft;
      const scrollY = html.scrollTop;
      return () => {
        // Doesn't work on Chrome iOS; Safari and Edge work correctly
        if ((0, _useScrollLock.getPreventScrollCount)() === 0) {
          html.scrollLeft = scrollX;
          html.scrollTop = scrollY;
        }
      };
    }
    return undefined;
  }, [enabled, popupRef]);
  const handlePress = (0, _useEventCallback.useEventCallback)(event => {
    if (!(0, _detectBrowser.isIOS)()) {
      return;
    }
    const target = (0, _utils.getTarget)(event.nativeEvent);
    if ((0, _utils.isTypeableElement)(target)) {
      setLock(false);
      setTimeout(() => setLock(true));
    }
  });
  return React.useMemo(() => ({
    floating: {
      onFocus: handlePress,
      onClick: handlePress
    }
  }), [handlePress]);
}