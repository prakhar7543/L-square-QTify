'use client';

import * as React from 'react';
import PropTypes from 'prop-types';
import { useComponentRenderer } from '../../utils/useComponentRenderer.js';
import { ToastRootContext } from './ToastRootContext.js';
import { useForkRef } from '../../utils/useForkRef.js';
import { transitionStatusMapping } from '../../utils/styleHookMapping.js';
import { visuallyHidden } from '../../utils/visuallyHidden.js';
import { useToastRoot } from './useToastRoot.js';
import { useToastContext } from '../provider/ToastProviderContext.js';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
const customStyleHookMapping = {
  ...transitionStatusMapping,
  swipeDirection(value) {
    return value ? {
      'data-swipe-direction': value
    } : null;
  }
};

/**
 * Groups all parts of an individual toast.
 * Renders a `<div>` element.
 *
 * Documentation: [Base UI Toast](https://base-ui.com/react/components/toast)
 */
const ToastRoot = /*#__PURE__*/React.forwardRef(function ToastRoot(props, forwardedRef) {
  const {
    toast,
    render,
    className,
    children,
    swipeDirection,
    ...other
  } = props;
  const {
    hovering,
    focused,
    hasDifferingHeights
  } = useToastContext();
  const toastRoot = useToastRoot({
    toast,
    swipeDirection: swipeDirection ?? ['down', 'right']
  });
  const mergedRef = useForkRef(toastRoot.rootRef, forwardedRef);
  const state = React.useMemo(() => ({
    transitionStatus: toast.transitionStatus,
    expanded: hovering || focused || hasDifferingHeights,
    limited: toast.limited || false,
    type: toast.type,
    swiping: toastRoot.swiping,
    swipeDirection: toastRoot.swipeDirection
  }), [hovering, focused, hasDifferingHeights, toast.transitionStatus, toast.limited, toast.type, toastRoot.swiping, toastRoot.swipeDirection]);
  const {
    renderElement
  } = useComponentRenderer({
    render: render ?? 'div',
    ref: mergedRef,
    className,
    state,
    customStyleHookMapping,
    propGetter: toastRoot.getRootProps,
    extraProps: {
      ...other,
      // Screen readers won't announce the text upon DOM insertion of the component.
      // We need to wait until the next tick to render the children so that screen
      // readers can announce the contents.
      children: /*#__PURE__*/_jsxs(React.Fragment, {
        children: [children, !focused && /*#__PURE__*/_jsx("div", {
          style: visuallyHidden,
          ...(toast.priority === 'high' ? {
            role: 'alert',
            'aria-atomic': true
          } : {
            role: 'status',
            'aria-live': 'polite'
          }),
          children: toastRoot.renderScreenReaderContent && /*#__PURE__*/_jsxs(React.Fragment, {
            children: [toast.title && /*#__PURE__*/_jsx("div", {
              children: toast.title
            }), toast.description && /*#__PURE__*/_jsx("div", {
              children: toast.description
            })]
          })
        })]
      })
    }
  });
  return /*#__PURE__*/_jsx(ToastRootContext.Provider, {
    value: toastRoot,
    children: renderElement()
  });
});
process.env.NODE_ENV !== "production" ? ToastRoot.propTypes /* remove-proptypes */ = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: PropTypes.node,
  /**
   * CSS class applied to the element, or a function that
   * returns a class based on the component’s state.
   */
  className: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  /**
   * Allows you to replace the component’s HTML element
   * with a different tag, or compose it with another component.
   *
   * Accepts a `ReactElement` or a function that returns the element to render.
   */
  render: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),
  /**
   * Direction(s) in which the toast can be swiped to dismiss.
   * Defaults to `['down', 'right']`.
   */
  swipeDirection: PropTypes.oneOfType([PropTypes.oneOf(['down', 'left', 'right', 'up']), PropTypes.arrayOf(PropTypes.oneOf(['down', 'left', 'right', 'up']).isRequired)]),
  /**
   * The toast to render.
   */
  toast: PropTypes.shape({
    actionProps: PropTypes.object,
    data: PropTypes.any,
    description: PropTypes.string,
    height: PropTypes.number,
    id: PropTypes.string.isRequired,
    limited: PropTypes.bool,
    onClose: PropTypes.func,
    onRemove: PropTypes.func,
    priority: PropTypes.oneOf(['high', 'low']),
    timeout: PropTypes.number,
    title: PropTypes.string,
    transitionStatus: PropTypes.oneOf(['ending', 'starting']),
    type: PropTypes.string
  }).isRequired
} : void 0;
export { ToastRoot };