import * as React from 'react';
import { useButton } from '../../use-button/index.js';
import { mergeProps } from '../../merge-props/index.js';
import { useEventCallback } from '../../utils/useEventCallback.js';
import { useForkRef } from '../../utils/useForkRef.js';
import { useEnhancedEffect } from '../../utils/index.js';
import { addHighlight, hasHighlight, removeHighlight } from '../../utils/highlighted.js';
import { isMouseWithinBounds } from '../../utils/isMouseWithinBounds.js';
export function useSelectItem(params) {
  const {
    open,
    disabled = false,
    highlighted,
    selected,
    ref: externalRef,
    setOpen,
    typingRef,
    handleSelect,
    selectionRef,
    indexRef,
    setActiveIndex,
    selectedIndexRef,
    popupRef,
    keyboardActiveRef,
    events
  } = params;
  const ref = React.useRef(null);
  const lastKeyRef = React.useRef(null);
  const pointerTypeRef = React.useRef('mouse');
  const didPointerDownRef = React.useRef(false);
  const prevPopupHeightRef = React.useRef(0);
  const allowFocusSyncRef = React.useRef(true);
  const cursorMovementTimerRef = React.useRef(-1);
  const mergedRef = useForkRef(externalRef, ref);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    buttonRef: mergedRef
  });
  const commitSelection = useEventCallback(event => {
    handleSelect(event);
    setOpen(false, event, undefined);
  });
  const handlePopupLeave = useEventCallback(() => {
    if (cursorMovementTimerRef.current !== -1) {
      clearTimeout(cursorMovementTimerRef.current);
      cursorMovementTimerRef.current = -1;
      removeHighlight(ref);
    }
  });
  React.useEffect(() => {
    return handlePopupLeave;
  }, [handlePopupLeave]);
  useEnhancedEffect(() => {
    if (!open) {
      return;
    }
    if (highlighted) {
      addHighlight(ref);
    } else {
      removeHighlight(ref);
    }
  }, [open, highlighted]);
  React.useEffect(() => {
    function handleItemHover(item) {
      if (ref.current && item !== ref.current) {
        removeHighlight(ref);
      }
    }
    events.on('itemhover', handleItemHover);
    return () => {
      events.off('itemhover', handleItemHover);
    };
  }, [events, setActiveIndex, indexRef]);
  const getItemProps = React.useCallback(externalProps => {
    return getButtonProps(mergeProps({
      'aria-disabled': disabled || undefined,
      tabIndex: highlighted ? 0 : -1,
      onFocus() {
        if (allowFocusSyncRef.current && keyboardActiveRef.current && cursorMovementTimerRef.current === -1) {
          setActiveIndex(indexRef.current);
        }
      },
      onMouseEnter() {
        if (!keyboardActiveRef.current && selectedIndexRef.current === null) {
          addHighlight(ref);
          events.emit('itemhover', ref.current);
        }
      },
      onMouseMove() {
        if (keyboardActiveRef.current) {
          setActiveIndex(indexRef.current);
        } else {
          addHighlight(ref);
          events.emit('itemhover', ref.current);
        }
        if (popupRef.current) {
          prevPopupHeightRef.current = popupRef.current.offsetHeight;
        }
        if (cursorMovementTimerRef.current !== -1) {
          events.off('popupleave', handlePopupLeave);
          clearTimeout(cursorMovementTimerRef.current);
        }
        events.on('popupleave', handlePopupLeave);
        // When this fires, the cursor has stopped moving.
        cursorMovementTimerRef.current = window.setTimeout(() => {
          setActiveIndex(indexRef.current);
          cursorMovementTimerRef.current = -1;
        }, 50);
      },
      onMouseLeave(event) {
        const popup = popupRef.current;
        if (!popup || !open || keyboardActiveRef.current) {
          return;
        }
        if (isMouseWithinBounds(event)) {
          return;
        }
        removeHighlight(ref);
        events.off('popupleave', handlePopupLeave);
        const wasCursorStationary = cursorMovementTimerRef.current === -1;
        if (!wasCursorStationary) {
          clearTimeout(cursorMovementTimerRef.current);
          cursorMovementTimerRef.current = -1;
        }

        // With `alignItemToTrigger`, avoid re-rendering the root due to `onMouseLeave`
        // firing and causing a performance issue when expanding the popup.
        if (popup.offsetHeight === prevPopupHeightRef.current) {
          // Prevent `onFocus` from causing the highlight to be stuck when quickly moving
          // the mouse out of the popup.
          allowFocusSyncRef.current = false;
          if (keyboardActiveRef.current || wasCursorStationary) {
            setActiveIndex(null);
          }
          requestAnimationFrame(() => {
            if (cursorMovementTimerRef.current !== -1) {
              clearTimeout(cursorMovementTimerRef.current);
            }
            allowFocusSyncRef.current = true;
          });
        }
      },
      onTouchStart() {
        selectionRef.current = {
          allowSelectedMouseUp: false,
          allowUnselectedMouseUp: false,
          allowSelect: true
        };
      },
      onKeyDown(event) {
        selectionRef.current.allowSelect = true;
        lastKeyRef.current = event.key;
        setActiveIndex(indexRef.current);
      },
      onClick(event) {
        didPointerDownRef.current = false;

        // Prevent double commit on {Enter}
        if (event.type === 'keydown' && lastKeyRef.current === null) {
          return;
        }
        if (disabled || lastKeyRef.current === ' ' && typingRef.current || pointerTypeRef.current !== 'touch' && !hasHighlight(ref)) {
          return;
        }
        if (selectionRef.current.allowSelect) {
          lastKeyRef.current = null;
          commitSelection(event.nativeEvent);
        }
      },
      onPointerEnter(event) {
        pointerTypeRef.current = event.pointerType;
      },
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
        didPointerDownRef.current = true;
      },
      onMouseUp(event) {
        if (disabled) {
          return;
        }
        if (didPointerDownRef.current) {
          didPointerDownRef.current = false;
          return;
        }
        const disallowSelectedMouseUp = !selectionRef.current.allowSelectedMouseUp && selected;
        const disallowUnselectedMouseUp = !selectionRef.current.allowUnselectedMouseUp && !selected;
        if (disallowSelectedMouseUp || disallowUnselectedMouseUp || pointerTypeRef.current !== 'touch' && !hasHighlight(ref)) {
          return;
        }
        if (selectionRef.current.allowSelect || !selected) {
          commitSelection(event.nativeEvent);
        }
        selectionRef.current.allowSelect = true;
      }
    }, externalProps, getButtonProps));
  }, [commitSelection, disabled, events, getButtonProps, handlePopupLeave, highlighted, indexRef, keyboardActiveRef, open, popupRef, selected, selectedIndexRef, selectionRef, setActiveIndex, typingRef]);
  return React.useMemo(() => ({
    getItemProps,
    rootRef: buttonRef
  }), [getItemProps, buttonRef]);
}